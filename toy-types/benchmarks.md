- 2022-02-04
- author: @cmyr
- preliminary benchmark numbers

All benchmarks generated by [criterion][], running on a 2021 macbook pro.
To run these benchmarks locally, checkout this repo and run `cargo bench`.

**take an existing cmap4 subtable and look up two glyph ids**
The cmap4 subtable already exists, so this is just the cost of the binary
search.

In the pure zerocopy implementation there is a bounds check at each array
access. In the \_checked implementation, the bounds are computed and verified
when the table is instantiated.
```
pod_cmap_lookup_retain          time:   [14.285 ns 14.293 ns 14.301 ns]
zc_cmap_lookup_retain           time:   [17.803 ns 17.815 ns 17.829 ns]
zc_cmap_lookup_retain_checked   time:   [12.774 ns 12.789 ns 12.805 ns]
```

**take an offset to a cmap4 subtable and look up two glyph ids**
This means parsing the subtable, which is more expensive in the pod case.
```
pod_cmap_lookup_get     time:   [28.946 ns 28.970 ns 28.995 ns]
zc_cmap_lookup_get      time:   [21.960 ns 21.976 ns 21.993 ns]
```

**from font root, access two fields from the head table**
This requires parsing the full head table in the pod case; the other cases
only pay for the fields they access.

The zc `_copy` test does a memcopy and returns an owned version of the zerocopy
type (This is confusing, but I was curious about this case because it might make
for better API sometimes)

```
pod_get_head_fields     time:   [29.720 ns 29.753 ns 29.789 ns]
view_get_head_fields    time:   [18.108 ns 18.138 ns 18.169 ns]
zc_get_head_fields      time:   [17.010 ns 17.041 ns 17.076 ns]
zc_get_head_fields_copy time:   [20.397 ns 20.433 ns 20.469 ns]
```

**finding vs accessing `head` table**
`find_head` times a binary search through the table records to find `head`.
the `_load_head` tests are how long it takes to convert the data (once found) to
either a (bounds-checked) zerocopy view or to a native Rust struct.

```
find_head               time:   [15.204 ns 15.221 ns 15.244 ns]
load_head_zc            time:   [1.8838 ns 1.8855 ns 1.8875 ns]
load_head_pod           time:   [7.2145 ns 7.2208 ns 7.2274 ns]
```

**take a glyf table and an offset and compute area of bounding box**

The difference between the view & zc numbers here is very interesting to me.
Some of it is that the view impl is not optimal and is including an elidable
bounds check on each field access, but that shouldn't explain the total
difference.
```
pod_glyph_bbox_only     time:   [1.9867 ns 1.9886 ns 1.9909 ns]
view_glyph_bbox_only    time:   [2.8163 ns 2.8204 ns 2.8264 ns]
zc_glyph_bbox_only      time:   [1.2526 ns 1.2544 ns 1.2565 ns]
```

**take font and gid, and compute area of bounding box.**
This involves accessing `head`, `loca` and then `glyf`, and most of the actual
performance difference seems to just be the difference in deserializing all of
`head`?
```
pod_glyph_bbox_root     time:   [61.895 ns 61.958 ns 62.040 ns]
view_glyph_bbox_root    time:   [50.670 ns 50.720 ns 50.780 ns]
```


[criterion]: https://docs.rs/criterion/latest/criterion/
